<!-- Este codigo es una prueba de agarres y arrastre usando las librerias de:
        Aframe: Desarrollo 3D
        Aframe-event-set: Manejo de eventos
        Aframe-extras: Extras
        Super-hands: Nos permite usar de forma sencilla acciones como Click, Drag, Drop o Grab
    El codigo aun está en desarrollo, la idea es poder usar la Realidad Virtual con este codigo para ser capaz de mover objetos usando
    el visor y controladores de Meta Quest 2.

    DATOS IMPORTARNTES:
        -El uso de las versiones deben ser las establecidas, para evitar fallos.
        -El codigo aun sigue en desarrollo, cualquier aportacion o sugerencia es bienvenida.
    
    Codigo realizado por Iván Seco Martín
    Comenzado: 12/11/2024-->

<!DOCTYPE html>
<html>

<head>
    <title>Prueba agarres y arrastre</title>
    <!-- HAY QUE USAR ESTAS VERSIONES SINO PETA -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@3.0.3/dist/aframe-event-set-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands@2.1.0/dist/super-hands.min.js"></script>
    <script src="https://gftruj.github.io/webzamples/aframe/controls/oculus-thumbstick-controls.js"></script>

</head>
<script>
    AFRAME.registerComponent('oculus-thumbstick-controls', {





        schema: {



            acceleration: { default: 45 },



            rigSelector: { default: "#rig" },



            fly: { default: false },



            controllerOriented: { default: false },



            adAxis: { default: 'x', oneOf: ['x', 'y', 'z'] },



            wsAxis: { default: 'z', oneOf: ['x', 'y', 'z'] },



            enabled: { default: true },



            adEnabled: { default: true },



            adInverted: { default: false },



            wsEnabled: { default: true },



            wsInverted: { default: false }



        },



        init: function () {



            this.easing = 1.1;



            this.velocity = new THREE.Vector3(0, 0, 0);



            this.tsData = new THREE.Vector2(0, 0);









            this.thumbstickMoved = this.thumbstickMoved.bind(this)



            this.el.addEventListener('thumbstickmoved', this.thumbstickMoved);



        },



        update: function () {



            this.rigElement = document.querySelector(this.data.rigSelector)



        },



        tick: function (time, delta) {



            if (!this.el.sceneEl.is('vr-mode')) return;



            var data = this.data;



            var el = this.rigElement



            var velocity = this.velocity;



            //console.log("here", this.tsData, this.tsData.length())



            if (!velocity[data.adAxis] && !velocity[data.wsAxis] && !this.tsData.length()) { return; }









            // Update velocity.



            delta = delta / 1000;



            this.updateVelocity(delta);









            if (!velocity[data.adAxis] && !velocity[data.wsAxis]) { return; }









            // Get movement vector and translate position.



            el.object3D.position.add(this.getMovementVector(delta));



        },



        updateVelocity: function (delta) {



            var acceleration;



            var adAxis;



            var adSign;



            var data = this.data;



            var velocity = this.velocity;



            var wsAxis;



            var wsSign;



            const CLAMP_VELOCITY = 0.00001;









            adAxis = data.adAxis;



            wsAxis = data.wsAxis;









            // If FPS too low, reset velocity.



            if (delta > 0.2) {



                velocity[adAxis] = 0;



                velocity[wsAxis] = 0;



                return;



            }









            // https://gamedev.stackexchange.com/questions/151383/frame-rate-independant-movement-with-acceleration



            var scaledEasing = Math.pow(1 / this.easing, delta * 60);



            // Velocity Easing.



            if (velocity[adAxis] !== 0) {



                velocity[adAxis] = velocity[adAxis] * scaledEasing;



            }



            if (velocity[wsAxis] !== 0) {



                velocity[wsAxis] = velocity[wsAxis] * scaledEasing;



            }









            // Clamp velocity easing.



            if (Math.abs(velocity[adAxis]) < CLAMP_VELOCITY) { velocity[adAxis] = 0; }



            if (Math.abs(velocity[wsAxis]) < CLAMP_VELOCITY) { velocity[wsAxis] = 0; }









            if (!data.enabled) { return; }









            // Update velocity using keys pressed.



            acceleration = data.acceleration;



            if (data.adEnabled && this.tsData.x) {



                adSign = data.adInverted ? -1 : 1;



                velocity[adAxis] += adSign * acceleration * this.tsData.x * delta;



            }



            if (data.wsEnabled) {



                wsSign = data.wsInverted ? -1 : 1;



                velocity[wsAxis] += wsSign * acceleration * this.tsData.y * delta;



            }



        },



        getMovementVector: (function () {



            var directionVector = new THREE.Vector3(0, 0, 0);



            var rotationEuler = new THREE.Euler(0, 0, 0, 'YXZ');









            return function (delta) {



                var rotation = this.el.sceneEl.camera.el.object3D.rotation



                var velocity = this.velocity;



                var xRotation;









                directionVector.copy(velocity);



                directionVector.multiplyScalar(delta);



                // Absolute.



                if (!rotation) { return directionVector; }



                xRotation = this.data.fly ? rotation.x : 0;









                // Transform direction relative to heading.



                rotationEuler.set(xRotation, rotation.y, 0);



                directionVector.applyEuler(rotationEuler);



                return directionVector;



            };



        })(),



        thumbstickMoved: function (evt) {



            this.tsData.set(evt.detail.x, evt.detail.y);



        },



        remove: function () {



            this.el.removeEventListener('thumbstickmoved', this.thumbstickMoved);



        }
        
    });
</script>

<body>
    <a-scene>
        <!-- Usamos el collider para detectar la interseccion con el objeto, le marcamos que usaremos la mano derecha para interactuar -->
        <a-entity sphere-collider="objects: a-box; " super-hands id="rightHand"
            hand-controls="hand: right; handModeStyle color: #ffcccc"></a-entity>
        <a-entity sphere-collider="objects: a-box; " super-hands id="lefttHand"
            hand-controls="hand: left;  color: #ffcccc"></a-entity>

        <!-- Añadimos el cursor para la camara -->
        <a-entity id="rig">

            <a-camera position="0 1.6 0">
                            <a-cursor></a-cursor>

            </a-camera>
    
            <a-entity oculus-touch-controls="hand: left" ></a-entity>
    
            <a-entity oculus-touch-controls="hand: right" oculus-thumbstick-controls></a-entity>
            
        </a-entity>



        <!-- mouse down y mouse up -->
        <a-box color=#AA0000 position="-1.5 0 -3 " clickable
            event-set__start="_event: grab-start; _target: #verde; material.color: #AA0000"
            event-set__end="_event: grab-end; _target: #verde; material.color: #00AA00">
        </a-box>

        <a-box id="verde" color=#00AA00 position="-1.5 3 -3" grabbable
            event-set__start="_event: grab-start; _target: #blue; material.color: #00AA00"
            event-set__end="_event: grab-end; _target: #blue; material.color: #00AAFF">

        </a-box>

        <a-box color=#FFAA00 position="1.5 3 -3" draggable
            event-set__drag="_event: drag-drop; _target: #blue; material.color: #FFAA00">


        </a-box>

        <a-box id="blue" color=#00AAFF position="1.5 0 -3" droppable>

        </a-box>

        <a-sphere position="0 0 0" color="black" grabbable></a-sphere>



        <a-plane position="0 0 0" rotation="-90 0 0" width="100" height="100" color="#7BC8A4"></a-plane>

        <!-- Edificios de la ciudad -->
        <a-box position="0 2 -10" depth="10" height="4" width="4" color="black" grabbable></a-box>
        <a-box position="5 4 -15" depth="5" height="8" width="5" color="#EF2D5E"></a-box>
        <a-box position="-5 6 -20" depth="6" height="12" width="6" color="#FFC65D"></a-box>
        <a-box position="10 3 -25" depth="4" height="6" width="4" color="#24CAFF"></a-box>

        <a-sky color="#87CEEB"></a-sky>



    </a-scene>
</body>

</html>
